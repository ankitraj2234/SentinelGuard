package com.sentinelguard.scanner

import android.content.Context
import android.content.pm.ApplicationInfo
import android.content.pm.PackageInfo
import android.content.pm.PackageManager
import android.content.pm.Signature
import android.os.Build
import android.os.Environment
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.flowOn
import kotlinx.coroutines.yield
import java.io.File
import java.io.FileInputStream
import java.security.MessageDigest
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Severity levels for detected threats
 */
enum class ThreatSeverity {
    LOW,        // Suspicious but not confirmed
    MEDIUM,     // Potentially harmful
    HIGH,       // Likely malware
    CRITICAL    // Confirmed malware
}

/**
 * Threat type categories
 */
enum class ThreatType {
    KNOWN_MALWARE,
    SUSPICIOUS_PERMISSIONS,
    SUSPICIOUS_NAME,
    UNSIGNED_APK,
    HIDDEN_APP,
    DANGEROUS_BEHAVIOR,
    SUSPICIOUS_FILE,
    SIDELOADED_APP
}

/**
 * Represents a detected threat
 */
data class DetectedThreat(
    val packageName: String,
    val appName: String,
    val type: ThreatType,
    val severity: ThreatSeverity,
    val description: String,
    val filePath: String? = null,
    val canUninstall: Boolean = true
)

/**
 * Scan progress update
 */
data class ScanProgress(
    val currentItem: String,
    val scannedCount: Int,
    val totalCount: Int,
    val threatsFound: Int,
    val phase: ScanPhase
)

enum class ScanPhase {
    INITIALIZING,
    SCANNING_APPS,
    SCANNING_FILES,
    ANALYZING,
    COMPLETE
}

/**
 * Final scan result
 */
data class ScanResult(
    val totalScanned: Int,
    val appsScanned: Int,
    val filesScanned: Int,
    val threats: List<DetectedThreat>,
    val scanDurationMs: Long,
    val timestamp: Long = System.currentTimeMillis()
)

/**
 * MalwareScanner: Scans device for malware and suspicious apps.
 * 
 * Key features:
 * - Whitelists system apps (FLAG_SYSTEM)
 * - Whitelists Google/AOSP apps
 * - Verifies Play Store installations
 * - Checks app signatures
 * - Only flags genuinely suspicious apps
 */
@Singleton
class MalwareScanner @Inject constructor(
    @ApplicationContext private val context: Context
) {
    
    private val packageManager: PackageManager = context.packageManager
    
    /**
     * Trusted package prefixes - these are NEVER flagged
     */
    private val trustedPrefixes = setOf(
        // Google apps
        "com.google.",
        "com.android.",
        // Samsung
        "com.samsung.",
        "com.sec.",
        // Xiaomi/MIUI
        "com.miui.",
        "com.xiaomi.",
        // OnePlus
        "com.oneplus.",
        "net.oneplus.",
        // Huawei
        "com.huawei.",
        // OPPO/Realme
        "com.oppo.",
        "com.realme.",
        "com.coloros.",
        // Vivo
        "com.vivo.",
        // LG
        "com.lge.",
        // Sony
        "com.sonymobile.",
        // Qualcomm
        "com.qualcomm.",
        // MediaTek
        "com.mediatek."
    )
    
    /**
     * Known Play Store installer package names
     */
    private val playStoreInstallers = setOf(
        "com.android.vending",           // Google Play Store
        "com.google.android.packageinstaller"
    )
    
    /**
     * Other trusted installers
     */
    private val trustedInstallers = setOf(
        "com.android.vending",           // Google Play
        "com.google.android.packageinstaller",
        "com.amazon.venezia",            // Amazon App Store
        "com.samsung.android.vending",   // Samsung Galaxy Store
        "com.huawei.appmarket",          // Huawei AppGallery
        "com.oppo.market",               // OPPO App Market
        "com.xiaomi.market",             // Mi App Store
        "com.sec.android.app.samsungapps", // Samsung Apps
        "com.bbk.appstore",              // Vivo App Store
        "com.heytap.market"              // Realme App Store
    )
    
    /**
     * COMPREHENSIVE WHITELIST: Popular trusted apps that should NEVER be flagged
     * These are legitimate mainstream apps used by millions of users
     */
    private val trustedApps = setOf(
        // ========== Meta/Facebook ==========
        "com.facebook.katana",           // Facebook
        "com.facebook.orca",             // Messenger
        "com.facebook.lite",             // Facebook Lite
        "com.facebook.mlite",            // Messenger Lite
        "com.instagram.android",         // Instagram
        "com.whatsapp",                  // WhatsApp
        "com.whatsapp.w4b",              // WhatsApp Business
        "com.facebook.pages.app",        // Facebook Pages Manager
        "com.facebook.appmanager",       // Facebook App Manager
        
        // ========== Microsoft ==========
        "com.microsoft.office.word",
        "com.microsoft.office.excel",
        "com.microsoft.office.powerpoint",
        "com.microsoft.office.outlook",
        "com.microsoft.teams",
        "com.microsoft.office.officelens",
        "com.microsoft.bing",
        "com.microsoft.launcher",
        "com.microsoft.todos",
        "com.microsoft.office.onenote",
        "com.skype.raider",              // Skype
        "com.linkedin.android",          // LinkedIn
        
        // ========== Social/Communication ==========
        "org.telegram.messenger",        // Telegram
        "com.snapchat.android",          // Snapchat
        "com.twitter.android",           // Twitter/X
        "com.zhiliaoapp.musically",      // TikTok
        "com.ss.android.ugc.trill",      // TikTok (other variant)
        "com.pinterest",                 // Pinterest
        "com.reddit.frontpage",          // Reddit
        "com.discord",                   // Discord
        "us.zoom.videomeetings",         // Zoom
        "com.viber.voip",                // Viber
        "com.imo.android.imoim",         // IMO
        "com.Slack",                     // Slack
        "jp.naver.line.android",         // LINE
        "com.kakao.talk",                // KakaoTalk
        "com.tencent.mm",                // WeChat
        "com.tencent.mobileqq",          // QQ
        
        // ========== Streaming/Entertainment ==========
        "com.netflix.mediaclient",       // Netflix
        "com.amazon.avod.thirdpartyclient", // Prime Video
        "com.disney.disneyplus",         // Disney+
        "com.spotify.music",             // Spotify
        "com.google.android.youtube",    // YouTube
        "com.google.android.apps.youtube.music", // YouTube Music
        "tv.twitch.android.app",         // Twitch
        "com.jio.jioplay.tv",            // JioTV
        "in.startv.hotstar",             // Hotstar
        "com.mxtech.videoplayer.ad",     // MX Player
        "com.mxtech.videoplayer.pro",
        
        // ========== Shopping ==========
        "com.amazon.mShop.android.shopping", // Amazon Shopping
        "com.flipkart.android",          // Flipkart
        "com.ebay.mobile",               // eBay
        "com.alibaba.aliexpresshd",      // AliExpress
        "in.amazon.mShop.android.shopping", // Amazon India
        "com.myntra.android",            // Myntra
        "com.target.ui",                 // Target
        "com.walmart.android",           // Walmart
        
        // ========== Banking & Finance (Major Banks) ==========
        "com.phonepe.app",               // PhonePe
        "net.one97.paytm",               // Paytm
        "com.google.android.apps.nbu.paisa.user", // Google Pay
        "in.org.npci.upiapp",            // BHIM
        "com.csam.icici.bank.imobile",   // ICICI
        "com.sbi.lotusintouch",          // SBI YONO
        "com.axis.mobile",               // Axis Mobile
        "com.hdfc.mobilebanking",        // HDFC
        "com.konylabs.cbhdfcbank",       // HDFC
        "com.paypal.android.p2pmobile",  // PayPal
        "com.venmo",                     // Venmo
        "com.robinhood.android",         // Robinhood
        
        // ========== Utilities & Productivity ==========
        "com.truecaller",                // Truecaller
        "com.grammarly.android.keyboard", // Grammarly
        "com.adobe.reader",              // Adobe Reader
        "com.adobe.scan.android",        // Adobe Scan
        "com.dropbox.android",           // Dropbox
        "com.evernote",                  // Evernote
        "com.notion.id",                 // Notion
        "com.todoist",                   // Todoist
        "com.ticktick.task",             // TickTick
        
        // ========== Travel & Transport ==========
        "com.ubercab",                   // Uber
        "com.olacabs.customer",          // Ola
        "in.swiggy.android",             // Swiggy
        "com.application.zomato",        // Zomato
        "com.makemytrip",                // MakeMyTrip
        "com.booking",                   // Booking.com
        "com.airbnb.android",            // Airbnb
        "com.lyft.android",              // Lyft
        
        // ========== News/Media ==========
        "com.ss.android.article.news",   // News apps
        "flipboard.app",                 // Flipboard
        "com.eterno",                    // Inshorts
        "com.guardian",                  // The Guardian
        "com.nytimes.android",           // NY Times
        
        // ========== Gaming ==========
        "com.supercell.clashofclans",
        "com.supercell.clashroyale",
        "com.supercell.brawlstars",
        "com.king.candycrushsaga",
        "com.pubg.imobile",              // BGMI
        "com.activision.callofduty.shooter",
        "com.ea.gp.fifamobile",
        "com.garena.game.freefire",
        "com.mobile.legends",
        "com.epicgames.fortnite",
        "com.innersloth.spacemafia",     // Among Us
        "com.roblox.client",
        
        // ========== Health & Fitness ==========
        "com.google.android.apps.fitness",
        "com.strava",
        "com.fitnesskeeper.runkeeper.pro",
        "com.nike.plusgps",
        "com.underarmour.myfitnesspal",
        
        // ========== Developer/Tech ==========
        "com.github.android",
        "io.github.nicehash",
        "com.termux",
        "com.nianticlabs.pokemongo"      // Pokemon GO
    )
    
    /**
     * Perform a full device scan
     */
    fun performFullScan(): Flow<ScanProgress> = flow {
        val startTime = System.currentTimeMillis()
        val threats = mutableListOf<DetectedThreat>()
        var scannedCount = 0
        
        emit(ScanProgress("Initializing scan...", 0, 0, 0, ScanPhase.INITIALIZING))
        
        // Get all installed apps
        val installedApps = packageManager.getInstalledPackages(
            PackageManager.GET_PERMISSIONS or PackageManager.GET_META_DATA
        )
        
        val totalApps = installedApps.size
        
        // Phase 1: Scan installed apps
        emit(ScanProgress("Scanning installed apps...", 0, totalApps, 0, ScanPhase.SCANNING_APPS))
        
        for (packageInfo in installedApps) {
            yield() // Allow cancellation
            
            val appName = packageInfo.applicationInfo?.loadLabel(packageManager)?.toString() ?: packageInfo.packageName
            
            emit(ScanProgress(appName, scannedCount, totalApps, threats.size, ScanPhase.SCANNING_APPS))
            
            // Analyze the app (with smart filtering)
            val appThreats = analyzeApp(packageInfo)
            threats.addAll(appThreats)
            
            scannedCount++
        }
        
        // Phase 2: Scan download folder
        emit(ScanProgress("Scanning downloads...", scannedCount, totalApps, threats.size, ScanPhase.SCANNING_FILES))
        
        val downloadThreats = scanDownloadFolder()
        threats.addAll(downloadThreats)
        
        // Phase 3: Complete
        emit(ScanProgress(
            "Scan complete",
            scannedCount,
            totalApps,
            threats.size,
            ScanPhase.COMPLETE
        ))
        
    }.flowOn(Dispatchers.IO)
    
    /**
     * Get final scan result after flow completes
     */
    suspend fun getFinalResult(progress: Flow<ScanProgress>): ScanResult {
        val startTime = System.currentTimeMillis()
        val threats = mutableListOf<DetectedThreat>()
        
        val installedApps = packageManager.getInstalledPackages(
            PackageManager.GET_PERMISSIONS or PackageManager.GET_META_DATA
        )
        
        for (packageInfo in installedApps) {
            val appThreats = analyzeApp(packageInfo)
            threats.addAll(appThreats)
        }
        
        val downloadThreats = scanDownloadFolder()
        threats.addAll(downloadThreats)
        
        val duration = System.currentTimeMillis() - startTime
        
        return ScanResult(
            totalScanned = installedApps.size,
            appsScanned = installedApps.size,
            filesScanned = countDownloadFiles(),
            threats = threats,
            scanDurationMs = duration
        )
    }
    
    /**
     * Quick scan - only user-installed apps
     */
    fun performQuickScan(): Flow<ScanProgress> = flow {
        var scannedCount = 0
        var threatsFound = 0
        
        emit(ScanProgress("Quick scan starting...", 0, 0, 0, ScanPhase.INITIALIZING))
        
        val userApps = packageManager.getInstalledPackages(
            PackageManager.GET_PERMISSIONS
        ).filter { 
            !isSystemApp(it) && !isTrustedApp(it.packageName)
        }
        
        val totalApps = userApps.size
        
        for (packageInfo in userApps) {
            yield()
            
            val appName = packageInfo.applicationInfo?.loadLabel(packageManager)?.toString() ?: packageInfo.packageName
            emit(ScanProgress(appName, scannedCount, totalApps, threatsFound, ScanPhase.SCANNING_APPS))
            
            val threats = analyzeApp(packageInfo)
            threatsFound += threats.size
            scannedCount++
        }
        
        emit(ScanProgress("Complete", scannedCount, totalApps, threatsFound, ScanPhase.COMPLETE))
        
    }.flowOn(Dispatchers.IO)
    
    /**
     * Analyze a single app for threats with SMART FILTERING
     */
    private fun analyzeApp(packageInfo: PackageInfo): List<DetectedThreat> {
        val threats = mutableListOf<DetectedThreat>()
        val packageName = packageInfo.packageName
        val appName = packageInfo.applicationInfo?.loadLabel(packageManager)?.toString() ?: packageName
        
        // ============ SMART FILTERING ============
        
        // 1. Skip ALL system apps
        if (isSystemApp(packageInfo)) {
            return emptyList()
        }
        
        // 2. Skip trusted vendor apps (Google, Samsung, etc.)
        if (isTrustedApp(packageName)) {
            return emptyList()
        }
        
        // 3. Skip apps installed from Play Store (verified)
        if (isFromPlayStore(packageName)) {
            // Even Play Store apps could be malware, but only check known malware names
            if (!ThreatDatabase.isKnownMalware(packageName)) {
                return emptyList()
            }
        }
        
        // ============ THREAT DETECTION ============
        
        // Check 1: Known malware package name
        if (ThreatDatabase.isKnownMalware(packageName)) {
            threats.add(DetectedThreat(
                packageName = packageName,
                appName = appName,
                type = ThreatType.KNOWN_MALWARE,
                severity = ThreatSeverity.CRITICAL,
                description = "This app is identified as known malware",
                canUninstall = true
            ))
            return threats // No need to check more
        }
        
        // Check 2: Sideloaded apps (not from any store)
        val isSideloaded = !isFromTrustedInstaller(packageName)
        
        // Even if sideloaded, skip trusted apps (in case installer detection failed)
        // This is a second safety net for popular apps
        if (packageName in trustedApps) {
            return emptyList()
        }
        
        val permissions = packageInfo.requestedPermissions?.toSet() ?: emptySet()
        val highRiskCount = ThreatDatabase.countHighRiskPermissions(permissions)
        
        // Check 3: Dangerous permission combinations (only for sideloaded apps with MANY permissions)
        // Must be sideloaded AND have dangerous combo AND have 6+ high-risk permissions
        if (isSideloaded && ThreatDatabase.hasDangerousPermissionCombo(permissions) && highRiskCount >= 6) {
            threats.add(DetectedThreat(
                packageName = packageName,
                appName = appName,
                type = ThreatType.SUSPICIOUS_PERMISSIONS,
                severity = ThreatSeverity.MEDIUM,
                description = "Sideloaded app with dangerous permission combination",
                canUninstall = true
            ))
        }
        
        // Check 4: Suspicious app name (hack, crack, spy, etc.) - Always flag these
        if (ThreatDatabase.hasSuspiciousName(appName) || ThreatDatabase.hasSuspiciousName(packageName)) {
            threats.add(DetectedThreat(
                packageName = packageName,
                appName = appName,
                type = ThreatType.SUSPICIOUS_NAME,
                severity = ThreatSeverity.HIGH,
                description = "App name contains suspicious keywords (hack, crack, spy, etc.)",
                canUninstall = true
            ))
        }
        
        // Check 5: Hidden sideloaded app with dangerous permissions
        // Only flag truly suspicious hidden apps (sideloaded + hidden + 5+ dangerous permissions)
        val launchIntent = packageManager.getLaunchIntentForPackage(packageName)
        val isHidden = launchIntent == null
        if (isHidden && isSideloaded && highRiskCount >= 5) {
            threats.add(DetectedThreat(
                packageName = packageName,
                appName = appName,
                type = ThreatType.HIDDEN_APP,
                severity = ThreatSeverity.MEDIUM,
                description = "Hidden sideloaded app with $highRiskCount dangerous permissions",
                canUninstall = true
            ))
        }
        
        // Note: We NO LONGER flag apps just for being sideloaded with some permissions
        // Only flag if there are genuine red flags (suspicious name, hidden + many permissions, etc.)
        
        return threats
    }
    
    /**
     * Check if app is a system app
     */
    private fun isSystemApp(packageInfo: PackageInfo): Boolean {
        val appInfo = packageInfo.applicationInfo ?: return false
        return (appInfo.flags and ApplicationInfo.FLAG_SYSTEM) != 0 ||
               (appInfo.flags and ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0
    }
    
    /**
     * Check if package is from a trusted vendor OR is a known trusted app
     */
    private fun isTrustedApp(packageName: String): Boolean {
        // Check exact match in trusted apps list
        if (packageName in trustedApps) {
            return true
        }
        // Check vendor prefixes
        return trustedPrefixes.any { packageName.startsWith(it) }
    }
    
    /**
     * Check if app was installed from Google Play Store
     */
    private fun isFromPlayStore(packageName: String): Boolean {
        return try {
            val installer = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                packageManager.getInstallSourceInfo(packageName).installingPackageName
            } else {
                @Suppress("DEPRECATION")
                packageManager.getInstallerPackageName(packageName)
            }
            installer in playStoreInstallers
        } catch (e: Exception) {
            false
        }
    }
    
    /**
     * Check if app was installed from any trusted source
     */
    private fun isFromTrustedInstaller(packageName: String): Boolean {
        return try {
            val installer = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                packageManager.getInstallSourceInfo(packageName).installingPackageName
            } else {
                @Suppress("DEPRECATION")
                packageManager.getInstallerPackageName(packageName)
            }
            installer != null && installer in trustedInstallers
        } catch (e: Exception) {
            false
        }
    }
    
    /**
     * Scan download folder for suspicious files
     */
    private fun scanDownloadFolder(): List<DetectedThreat> {
        val threats = mutableListOf<DetectedThreat>()
        
        try {
            val downloadDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
            if (downloadDir.exists() && downloadDir.isDirectory) {
                downloadDir.listFiles()?.forEach { file ->
                    if (file.extension.lowercase() == "apk") {
                        // Check APK hash
                        val hash = calculateSHA256(file)
                        if (hash != null && ThreatDatabase.isKnownMalwareHash(hash)) {
                            threats.add(DetectedThreat(
                                packageName = "file",
                                appName = file.name,
                                type = ThreatType.KNOWN_MALWARE,
                                severity = ThreatSeverity.CRITICAL,
                                description = "APK file matches known malware signature",
                                filePath = file.absolutePath,
                                canUninstall = false
                            ))
                        }
                    }
                }
            }
        } catch (e: Exception) {
            // Permission denied or other error
        }
        
        return threats
    }
    
    private fun countDownloadFiles(): Int {
        return try {
            val downloadDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
            downloadDir.listFiles()?.size ?: 0
        } catch (e: Exception) {
            0
        }
    }
    
    /**
     * Calculate SHA-256 hash of a file
     */
    private fun calculateSHA256(file: File): String? {
        return try {
            val digest = MessageDigest.getInstance("SHA-256")
            FileInputStream(file).use { fis ->
                val buffer = ByteArray(8192)
                var bytesRead: Int
                while (fis.read(buffer).also { bytesRead = it } != -1) {
                    digest.update(buffer, 0, bytesRead)
                }
            }
            digest.digest().joinToString("") { "%02x".format(it) }
        } catch (e: Exception) {
            null
        }
    }
}
